<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cesium Animations Showcase (NASA GIBS + Local Build)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Local Cesium build -->
  <link rel="stylesheet" href="./Build/Cesium/Widgets/widgets.css">
  <style>
    html, body, #cesiumContainer { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background:#0b1120; }
    .toolbar {
      position:absolute; top:10px; left:10px; z-index:5;
      display:flex; align-items:center; gap:10px; padding:10px 12px;
      background:rgba(0,0,0,0.55); border-radius:12px; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial;
      box-shadow:0 10px 30px rgba(0,0,0,0.4);
    }
    .toolbar label { display:flex; align-items:center; gap:6px; font-size:14px; opacity:.95; }
    .toolbar button, .toolbar select {
      background:#111827; color:#e5e7eb; border:1px solid #374151;
      padding:6px 10px; border-radius:8px; cursor:pointer; font-weight:600;
    }
    .toolbar button:hover { background:#1f2937; }
    .toolbar .muted { opacity:.8; font-size:12px; }
    .toolbar .spacer { width:10px; height:1px; }

    /* Recording badge (top-right) */
    .rec-badge {
      position:absolute; top:10px; right:10px; z-index:6;
      display:flex; align-items:center; gap:8px;
      background:rgba(220, 38, 38, 0.92); color:#fff; font-weight:700;
      padding:6px 12px; border-radius:9999px; box-shadow:0 10px 30px rgba(0,0,0,0.4);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial;
    }
    .rec-dot { width:10px; height:10px; background:#fff; border-radius:50%; animation:pulse 1s infinite; }
    @keyframes pulse { 0%{opacity:1} 50%{opacity:.3} 100%{opacity:1} }
    .hidden { display:none; }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>

  <!-- Controls -->
  <div class="toolbar">
    <label><input id="chkNDVI"  type="checkbox" checked> NDVI</label>
    <label><input id="chkFires" type="checkbox" checked> Fires</label>
    <label><input id="chkAOD"   type="checkbox"> Aerosol</label>
    <button id="btnPlay" title="Play/Pause the timeline">‚èØÔ∏é</button>
    <select id="speed" title="Playback speed">
      <option value="600">600√ó</option>
      <option value="2400" selected>2400√ó</option>
      <option value="86400">86400√ó</option>
    </select>
    <span class="spacer"></span>
    <button id="recStart" title="Live recording of exactly what you see (you control the timeline)">‚è∫ Start LIVE Rec (24 fps)</button>
    <button id="recStop" disabled title="Stop current recording">‚èπ Stop</button>
    <button id="recScripted" title="Scripted recording: advance date, wait for tiles, hold, repeat">üé¨ Rec SCRIPTED (preload/step, 24 fps)</button>
    <button id="convertMp4" disabled title="Convert last WebM recording to MP4">‚û°Ô∏è Convert to MP4</button>
    <span id="loading" class="muted"></span>
    <span id="conv" class="muted"></span>
  </div>

  <!-- Recording indicator -->
  <div id="recBadge" class="rec-badge hidden" aria-live="polite">
    <div class="rec-dot"></div>
    <span id="recMode">REC</span>
    <span id="recTime">00:00</span>
  </div>

  <script src="./Build/Cesium/Cesium.js"></script>
  <!-- FFmpeg.wasm (for in-browser WebM ‚Üí MP4, if needed) -->
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/ffmpeg.min.js"></script>

  <script>
    // =========================
    // Viewer (no ion; ellipsoid terrain)
    // =========================
    const viewer = new Cesium.Viewer("cesiumContainer", {
      animation: true,
      timeline: true,
      baseLayerPicker: false,
      geocoder: false,
      sceneModePicker: true
    });
    viewer.scene.globe.enableLighting = true;
    viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#0b1120');
    viewer.scene.skyAtmosphere.show = false;
    viewer.shadows = false;
    viewer.scene.requestRenderMode = false;  // continuous rendering (helps fades/recording)

    // =========================
    // 1) Time window & camera on California
    // =========================
    const start = Cesium.JulianDate.fromDate(new Date(Date.UTC(2019, 0, 1)));
    const stop  = Cesium.JulianDate.fromDate(new Date(Date.UTC(2021,11,31)));
    viewer.clock.startTime = start.clone();
    viewer.clock.stopTime  = stop.clone();
    viewer.clock.currentTime = start.clone();
    viewer.clock.clockRange = Cesium.ClockRange.CLAMPED;
    viewer.clock.multiplier = 2400;
    viewer.timeline.zoomTo(start, stop);
    const CA_RECT = Cesium.Rectangle.fromDegrees(-125.0, 32.0, -113.5, 43.0);
    viewer.camera.flyTo({ destination: CA_RECT, duration: 0 });

    const ymd = jd => {
      const d = Cesium.JulianDate.toDate(jd);
      const pad = n => (n<10?'0':'')+n;
      return `${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}`;
    };
    function snapTo16DayISO(jd) {
      const d = Cesium.JulianDate.toDate(jd);
      const t = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
      const day = Math.floor((t - Date.UTC(d.getUTCFullYear(),0,1))/86400000) + 1;
      const snapped = day - ((day-1) % 16);
      const snapDate = new Date(Date.UTC(d.getUTCFullYear(),0,1));
      snapDate.setUTCDate(snapped);
      const pad = n => (n<10?'0':'')+n;
      return `${snapDate.getUTCFullYear()}-${pad(snapDate.getUTCMonth()+1)}-${pad(snapDate.getUTCDate())}`;
    }

    // =========================
    // 2) Imagery layers (token-free via GIBS)
    // =========================
    const layers = viewer.imageryLayers;
    layers.removeAll();

    // Tile progress tracker (for preload logic)
    let tileProgress = 0;
    viewer.scene.globe.tileLoadProgressEvent.addEventListener((n) => { tileProgress = n; });

    function waitUntilTilesSettled(baseline, timeoutMs = 8000) {
      return new Promise((resolve) => {
        let stableEvents = 0;
        const start = performance.now();
        function tick() {
          if (tileProgress <= baseline) stableEvents++; else stableEvents = 0;
          const timedOut = performance.now() - start > timeoutMs;
          if (stableEvents >= 2 || timedOut) resolve();
          else requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      });
    }

    async function preloadAndCrossfade(oldLayer, buildNewLayer, targetAlpha = 1.0, fadeMs = 350) {
      const baseline = tileProgress;
      const newLayer = buildNewLayer(); // adds the layer
      newLayer.alpha = 0.0001;
      newLayer.show = true;
      await waitUntilTilesSettled(baseline);
      const t0 = performance.now();
      return new Promise((resolve) => {
        function step(t) {
          const k = Math.min((t - t0) / fadeMs, 1);
          newLayer.alpha = targetAlpha * k;
          if (oldLayer) oldLayer.alpha = (1 - k) * (oldLayer.alpha ?? 1);
          viewer.scene.requestRender();
          if (k < 1) requestAnimationFrame(step);
          else { if (oldLayer) layers.remove(oldLayer, true); resolve(newLayer); }
        }
        requestAnimationFrame(step);
      });
    }

    let rebuildBusy = false;
    let lastSwitchAt = 0;
    const MIN_SWITCH_MS = 500;

    function silence404(provider) {
      provider.errorEvent.addEventListener((err) => {
        const msg = (err && (err.message || err.error)) || "";
        if (/404|Not\sFound|NoSuchKey/i.test(String(msg))) err.retry = false;
      });
    }

    function addViirsTrueColor(dayStr) {
      const prov = new Cesium.UrlTemplateImageryProvider({
        url: "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/VIIRS_SNPP_CorrectedReflectance_TrueColor/default/{Time}/GoogleMapsCompatible_Level9/{z}/{y}/{x}.jpg",
        tilingScheme: new Cesium.WebMercatorTilingScheme(),
        maximumLevel: 8,
        credit: "NASA EOSDIS GIBS",
        customTags: { Time: () => dayStr }
      });
      silence404(prov);
      const layer = layers.addImageryProvider(prov);
      layer.rectangle = CA_RECT;
      return layer;
    }

    function addNdvi16Day(dayStr16) {
      const prov = new Cesium.UrlTemplateImageryProvider({
        url: "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Terra_L3_NDVI_16Day/default/{Time}/GoogleMapsCompatible_Level9/{z}/{y}/{x}.png",
        tilingScheme: new Cesium.WebMercatorTilingScheme(),
        maximumLevel: 7,
        credit: "NASA EOSDIS GIBS",
        customTags: { Time: () => dayStr16 }
      });
      silence404(prov);
      const layer = layers.addImageryProvider(prov);
      layer.rectangle = CA_RECT;
      return layer;
    }

    function addGibsFires(dayStr) {
      const prov = new Cesium.UrlTemplateImageryProvider({
        url: "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Combined_Thermal_Anomalies_Day/default/{Time}/GoogleMapsCompatible_Level6/{z}/{y}/{x}.png",
        tilingScheme: new Cesium.WebMercatorTilingScheme(),
        maximumLevel: 6,
        credit: "NASA EOSDIS GIBS",
        customTags: { Time: () => dayStr }
      });
      silence404(prov);
      const layer = layers.addImageryProvider(prov);
      layer.rectangle = CA_RECT;
      return layer;
    }

    function addAerosolDaily(dayStr) {
      const prov = new Cesium.UrlTemplateImageryProvider({
        url: "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Aqua_Aerosol/default/{Time}/GoogleMapsCompatible_Level9/{z}/{y}/{x}.png",
        tilingScheme: new Cesium.WebMercatorTilingScheme(),
        maximumLevel: 7,
        credit: "NASA EOSDIS GIBS",
        customTags: { Time: () => dayStr }
      });
      silence404(prov);
      const layer = layers.addImageryProvider(prov);
      layer.rectangle = CA_RECT;
      return layer;
    }

    // Rebuild-on-day-change + visibility toggles
    let lastDay = null, lastDay16 = null;
    let viirsLayer = null, ndviLayer = null, firesLayer = null, aodLayer = null;
    let showNDVI = true, showFires = true, showAOD = false;

    async function rebuildFor(currentJD) {
      if (rebuildBusy) return;
      rebuildBusy = true;

      const dayStr   = ymd(currentJD);
      const dayStr16 = snapTo16DayISO(currentJD);

      if (!viirsLayer || lastDay !== dayStr) {
        viirsLayer = await preloadAndCrossfade(
          viirsLayer,
          () => { const L = addViirsTrueColor(dayStr); L.alpha = 0; return L; },
          1.0, 350
        );
      }

      if (showNDVI) {
        if (!ndviLayer || lastDay16 !== dayStr16) {
          ndviLayer = await preloadAndCrossfade(
            ndviLayer,
            () => { const L = addNdvi16Day(dayStr16); L.alpha = 0; return L; },
            0.6, 350
          );
        }
      } else if (ndviLayer) { layers.remove(ndviLayer, true); ndviLayer = null; }

      if (showFires) {
        if (!firesLayer || lastDay !== dayStr) {
          firesLayer = await preloadAndCrossfade(
            firesLayer,
            () => { const L = addGibsFires(dayStr); L.alpha = 0; return L; },
            1.0, 350
          );
        }
      } else if (firesLayer) { layers.remove(firesLayer, true); firesLayer = null; }

      if (showAOD) {
        if (!aodLayer || lastDay !== dayStr) {
          aodLayer = await preloadAndCrossfade(
            aodLayer,
            () => { const L = addAerosolDaily(dayStr); L.alpha = 0; return L; },
            0.5, 350
          );
        }
      } else if (aodLayer) { layers.remove(aodLayer, true); aodLayer = null; }

      lastDay = dayStr;
      lastDay16 = dayStr16;
      lastSwitchAt = performance.now();
      rebuildBusy = false;
    }

    rebuildFor(viewer.clock.currentTime);
    viewer.clock.onTick.addEventListener(() => {
      const dayNow = ymd(viewer.clock.currentTime);
      const since  = performance.now() - lastSwitchAt;
      if (dayNow !== lastDay && since >= MIN_SWITCH_MS && !rebuildBusy) rebuildFor(viewer.clock.currentTime);
    });

    // UI wiring
    const chkNDVI  = document.getElementById('chkNDVI');
    const chkFires = document.getElementById('chkFires');
    const chkAOD   = document.getElementById('chkAOD');
    const btnPlay  = document.getElementById('btnPlay');
    const speedSel = document.getElementById('speed');
    const loading  = document.getElementById('loading');
    const convNote = document.getElementById('conv');

    chkNDVI.onchange  = () => { showNDVI  = chkNDVI.checked;  rebuildFor(viewer.clock.currentTime); };
    chkFires.onchange = () => { showFires = chkFires.checked; rebuildFor(viewer.clock.currentTime); };
    chkAOD.onchange   = () => { showAOD   = chkAOD.checked;   rebuildFor(viewer.clock.currentTime); };

    btnPlay.onclick = () => {
      viewer.clock.shouldAnimate = !viewer.clock.shouldAnimate;
      btnPlay.textContent = viewer.clock.shouldAnimate ? "‚è∏Ô∏é" : "‚èØÔ∏é";
    };
    speedSel.onchange = () => { viewer.clock.multiplier = Number(speedSel.value); };

    viewer.scene.globe.tileLoadProgressEvent.addEventListener((num) => {
      loading.textContent = num ? `loading tiles: ${num}` : '';
    });

    // Legend
    viewer.entities.add({
      position: Cesium.Cartesian3.fromDegrees(-124.2, 42.7),
      label: {
        text: "VIIRS True Color + MODIS NDVI + GIBS Thermal Anomalies",
        font: "14px sans-serif",
        fillColor: Cesium.Color.WHITE,
        showBackground: true
      }
    });

    // =========================
    // 6) Recording (24 fps) + MP4 conversion + visible status
    // =========================
    let mediaRecorder = null;
    let recordedChunks = [];
    let lastRecordingBlob = null;
    let lastRecordingType = '';
    let recTimer = null;
    let recStartMs = 0;

    const recBadge = document.getElementById('recBadge');
    const recMode  = document.getElementById('recMode');
    const recTime  = document.getElementById('recTime');

    function setRecUI(active, modeText = 'REC') {
      if (active) {
        recMode.textContent = modeText;
        recStartMs = performance.now();
        recBadge.classList.remove('hidden');
        clearInterval(recTimer);
        recTimer = setInterval(() => {
          const s = Math.floor((performance.now() - recStartMs) / 1000);
          const mm = String(Math.floor(s/60)).padStart(2,'0');
          const ss = String(s % 60).padStart(2,'0');
          recTime.textContent = `${mm}:${ss}`;
        }, 250);
      } else {
        recBadge.classList.add('hidden');
        clearInterval(recTimer);
      }
    }

    function pickRecorderMime() {
      if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264')) return 'video/mp4;codecs=h264';
      if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) return 'video/webm;codecs=vp9';
      return 'video/webm;codecs=vp8';
    }

    function startRecording(fps = 24, modeLabel = 'LIVE') {
      const canvas = viewer.scene.canvas;
      const stream = canvas.captureStream(fps);
      const mimeType = pickRecorderMime();

      recordedChunks = [];
      mediaRecorder = new MediaRecorder(stream, { mimeType });
      mediaRecorder.ondataavailable = (e) => { if (e.data.size) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        lastRecordingBlob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'video/webm' });
        lastRecordingType = lastRecordingBlob.type || '';
        const directMp4 = /mp4/i.test(lastRecordingType);

        // Auto-download native recording
        const url = URL.createObjectURL(lastRecordingBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `cesium-${directMp4 ? 'recording' : 'webm'}-${new Date().toISOString().replace(/[:.]/g,'-')}.${directMp4 ? 'mp4' : 'webm'}`;
        a.click();
        URL.revokeObjectURL(url);

        document.getElementById('convertMp4').disabled = directMp4;
        convNote.textContent = directMp4 ? 'Recorded directly to MP4 (no conversion needed).' : 'Ready to convert WebM ‚Üí MP4.';
        setRecUI(false);
      };
      mediaRecorder.start(100);

      // Buttons
      document.getElementById('recStart').disabled = true;
      document.getElementById('recStop').disabled  = false;
      document.getElementById('convertMp4').disabled = true;
      convNote.textContent = '';

      setRecUI(true, modeLabel);
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      document.getElementById('recStart').disabled = false;
      document.getElementById('recStop').disabled  = true;
    }

    // Scripted (preload/step) capture at 24 fps
    let scriptedStop = false;
    async function recordTimelineScripted24({ stepDays = 1, holdSeconds = 0.5, fps = 24 } = {}) {
      scriptedStop = false;
      const prevAnimate = viewer.clock.shouldAnimate;
      viewer.clock.shouldAnimate = false;
      startRecording(fps, 'SCRIPT');

      let t = viewer.clock.currentTime.clone();
      const end = viewer.clock.stopTime;

      while (!scriptedStop && Cesium.JulianDate.lessThanOrEquals(t, end)) {
        await rebuildFor(t);                  // wait preload+fade
        viewer.clock.currentTime = t;
        await new Promise(r => setTimeout(r, holdSeconds * 1000));
        t = Cesium.JulianDate.addDays(t, stepDays, new Cesium.JulianDate());
      }

      stopRecording();
      viewer.clock.shouldAnimate = prevAnimate;
    }

    // In-browser WebM ‚Üí MP4 conversion with FFmpeg.wasm
    const { createFFmpeg, fetchFile } = FFmpeg;
    const ffmpeg = createFFmpeg({ log: true });
    let ffmpegLoaded = false;

    async function convertLastRecordingToMp4() {
      if (!lastRecordingBlob) { convNote.textContent = 'No recording to convert.'; return; }
      if (/mp4/i.test(lastRecordingType)) { convNote.textContent = 'Already MP4.'; return; }

      convNote.textContent = 'Loading FFmpeg‚Ä¶';
      if (!ffmpegLoaded) {
        await ffmpeg.load();
        ffmpegLoaded = true;
      }

      convNote.textContent = 'Preparing input‚Ä¶';
      await ffmpeg.FS('writeFile', 'input.webm', await fetchFile(lastRecordingBlob));

      convNote.textContent = 'Converting (H.264, 24 fps)‚Ä¶';
      ffmpeg.setProgress(({ ratio }) => {
        const pct = Math.max(0, Math.min(100, Math.round((ratio || 0) * 100)));
        convNote.textContent = `Converting: ${pct}%`;
      });

      await ffmpeg.run(
        '-i', 'input.webm',
        '-r', '24',
        '-c:v', 'libx264',
        '-pix_fmt', 'yuv420p',
        '-profile:v', 'high',
        '-level', '4.1',
        '-movflags', 'faststart',
        'output.mp4'
      );

      const data = ffmpeg.FS('readFile', 'output.mp4');
      const mp4Blob = new Blob([data.buffer], { type: 'video/mp4' });
      const url = URL.createObjectURL(mp4Blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cesium-converted-${new Date().toISOString().replace(/[:.]/g,'-')}.mp4`;
      a.click();
      URL.revokeObjectURL(url);

      convNote.textContent = 'MP4 ready ‚úÖ';
      document.getElementById('convertMp4').disabled = true;
    }

    // Wire buttons (with clear tooltips/labels)
    document.getElementById('recStart').onclick     = () => startRecording(24, 'LIVE');
    document.getElementById('recStop').onclick      = () => { scriptedStop = true; stopRecording(); };
    document.getElementById('recScripted').onclick  = () => recordTimelineScripted24({ stepDays: 1, holdSeconds: 0.5, fps: 24 });
    document.getElementById('convertMp4').onclick   = convertLastRecordingToMp4;

    // Start playing by default
    viewer.clock.shouldAnimate = true;
    document.getElementById('btnPlay').textContent = "‚è∏Ô∏é";
  </script>
</body>
</html>
