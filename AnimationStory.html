<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Terra ‚Üí Fire ‚Üí Smoke ‚Üí People (California Arc)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="./Build/Cesium/Widgets/widgets.css">
  <style>
    :root {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Helvetica, Arial, sans-serif;
      color-scheme: dark;
    }

    html,
    body,
    #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0b1120;
    }

    .toolbar,
    .metrics,
    .info,
    #ndviLegend,
    .caption {
      position: absolute;
      z-index: 10000;
      background: rgba(0, 0, 0, .55);
      color: #fff;
      border-radius: 12px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, .45);
    }

    .toolbar {
      top: 12px;
      left: 12px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      padding: 12px 14px;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      opacity: .95;
      white-space: nowrap;
    }

    .toolbar button,
    .toolbar select {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #374151;
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }

    .toolbar button:hover,
    .toolbar select:hover {
      background: #1f2937;
    }

    .toolbar .spacer {
      width: 12px;
      height: 1px;
      flex: 0 0 12px;
    }

    .toolbar .muted {
      opacity: .75;
      font-size: 12px;
    }

    .caption {
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      max-width: min(900px, 90vw);
      padding: 12px 16px;
      background: linear-gradient(180deg, rgba(0, 0, 0, .40), rgba(0, 0, 0, .70));
      font-size: 14px;
      line-height: 1.45;
      opacity: 0;
      transition: opacity .35s ease;
    }

    .caption.show {
      opacity: 1;
    }

    .cap-title {
      font-weight: 800;
      letter-spacing: .3px;
      margin-bottom: 4px;
      font-size: 15px;
    }

    .metrics {
      top: 12px;
      right: 12px;
      padding: 10px 12px;
      font-size: 12px;
      min-width: 190px;
    }

    #ndviLegend {
      right: 12px;
      bottom: 12px;
      padding: 10px 12px;
      font-size: 12px;
    }

    .info {
      left: 12px;
      bottom: 12px;
      padding: 10px 12px;
      font-size: 12px;
      max-width: min(520px, 90vw);
    }

    .info summary {
      cursor: pointer;
      font-weight: 700;
    }

    .info details {
      opacity: .95;
    }

    table.meta-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      line-height: 1.4;
    }

    table.meta-table td {
      padding: 2px 0;
    }
  </style>
</head>
<body>
  <!--
    QUICK GUIDE
    ===========
    ‚Ä¢ Put monthly FIRMS GeoJSON files at: ./data/firms/CA-YYYY-MM.geojson
    ‚Ä¢ Update the "chapters" array near the bottom to edit camera bookmarks, default layers, and captions.
    ‚Ä¢ Layers stream from public NASA GIBS WMTS endpoints; availability may lag for a given day/month.
  -->

  <div id="cesiumContainer" role="presentation"></div>

  <div class="toolbar" role="group" aria-label="Layer and story controls">
    <label><input id="chkHill" type="checkbox" checked> ASTER Hillshade</label>
    <label><input id="chkNDVI" type="checkbox" checked> NDVI (16-day)</label>
    <label><input id="chkLST" type="checkbox"> LST (day)</label>
    <label><input id="chkSnow" type="checkbox"> Snow</label>
    <label><input id="chkBurn" type="checkbox"> Burned Area (monthly)</label>
    <label><input id="chkAOD" type="checkbox"> Aerosol (Terra)</label>

    <span class="spacer" aria-hidden="true"></span>
    <label><input id="chkFiresIcons" type="checkbox" checked> Fire detections (FIRMS)</label>

    <span class="spacer" aria-hidden="true"></span>
    <button id="btnPrev" type="button">‚üµ Prev</button>
    <select id="chapterSel" title="Storyboard chapters"></select>
    <button id="btnNext" type="button">Next ‚ü∂</button>

    <span class="spacer" aria-hidden="true"></span>
    <button id="btnPlay" type="button" title="Play / pause timeline">‚èØÔ∏é</button>
    <select id="speed" title="Playback speed">
      <option value="600">600√ó</option>
      <option value="2400" selected>2400√ó</option>
      <option value="86400">86400√ó</option>
    </select>

    <span class="spacer" aria-hidden="true"></span>
    <button id="btnTestFires" type="button" title="Jump to California 2020‚Äë09‚Äë10">üî• Test Fires</button>

    <span class="spacer" aria-hidden="true"></span>
    <span id="loading" class="muted" role="status"></span>
  </div>

  <div id="caption" class="caption" aria-live="polite">
    <div class="cap-title" id="capTitle"></div>
    <div class="cap-why" id="capWhy"></div>
  </div>

  <div class="metrics" id="metrics">
    <div><strong>Chapter</strong>: <span id="mChapter">‚Äî</span></div>
    <div><strong>Date</strong>: <span id="mDate">‚Äî</span></div>
    <div><strong>Fire detections in view</strong>: <span id="mIcons">0</span></div>
    <div id="mNotes" style="opacity:.85"></div>
  </div>

  <div id="ndviLegend">
    <div style="font-weight:700;margin-bottom:6px">NDVI (16‚Äëday)</div>
    <div style="display:flex;align-items:center;gap:8px">
      <div style="width:160px;height:10px;background:linear-gradient(to right,#6e6e6e,#c9d66b,#4caf50,#006400)"></div>
      <div style="white-space:nowrap">low ‚Üí high</div>
    </div>
    <div style="display:flex;justify-content:space-between;margin-top:4px;opacity:.9">
      <span>&lt;0.1 barren/snow</span><span>0.2‚Äì0.5 shrubs/grass</span><span>0.6‚Äì0.8 forests</span>
    </div>
  </div>

  <div class="info">
    <details open>
      <summary>‚ÑπÔ∏è Integrity & caveats</summary>
      <div style="margin-top:6px; line-height:1.35">
        NDVI is a 16-day composite; clouds can mask short-term changes. Burned Area is monthly (MCD64A1); small fires may be delayed.
        AOD (Terra) is column optical depth; smoke impacts vary with height. LST is land skin temperature, not 2 m air temperature.
        Snow cover is NDSI-based; patchy snow and shadows reduce accuracy. ASTER GDEM hillshade is static context terrain.
        FIRMS fire detections are thermal anomalies; icon color shows confidence, size scales with FRP (radiative power).
      </div>
    </details>
  </div>

  <script src="./Build/Cesium/Cesium.js"></script>
  <script>
    /*
      STORY ENGINE OVERVIEW
      =====================
      ‚Ä¢ Rebuild imagery layers whenever the date or toggles change.
      ‚Ä¢ Fire detections pull from local monthly FIRMS GeoJSON files (./data/firms/CA-YYYY-MM.geojson).
      ‚Ä¢ Chapters define camera bounds, target date, cadence, default layer visibility, and captions.
      ‚Ä¢ Editing the story only requires adjusting the "chapters" array below.
    */

    // --- Viewer setup -------------------------------------------------------
    const viewer = new Cesium.Viewer("cesiumContainer", {
      animation: true,
      timeline: true,
      baseLayerPicker: false,
      geocoder: false,
      sceneModePicker: true
    });

    viewer.scene.globe.enableLighting = true;
    viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString("#0b1120");
    viewer.scene.skyAtmosphere.show = false;
    viewer.shadows = false;
    viewer.scene.requestRenderMode = false;
    viewer.infoBox.frame.setAttribute("sandbox", "allow-same-origin allow-popups allow-forms allow-scripts");

    const start = Cesium.JulianDate.fromDate(new Date(Date.UTC(2019, 0, 1)));
    const stop = Cesium.JulianDate.fromDate(new Date(Date.UTC(2021, 11, 31)));
    viewer.clock.startTime = start.clone();
    viewer.clock.stopTime = stop.clone();
    viewer.clock.currentTime = start.clone();
    viewer.clock.clockRange = Cesium.ClockRange.CLAMPED;
    viewer.clock.multiplier = 2400;
    viewer.timeline.zoomTo(start, stop);

    const CA_RECT = Cesium.Rectangle.fromDegrees(-125.0, 32.0, -113.5, 43.0);
    viewer.camera.flyTo({ destination: CA_RECT, duration: 0 });

    const layers = viewer.imageryLayers;
    layers.removeAll();

    // --- Date helpers -------------------------------------------------------
    const pad2 = value => value < 10 ? `0${value}` : String(value);
    const formatDay = jd => {
      const d = Cesium.JulianDate.toDate(jd);
      return `${d.getUTCFullYear()}-${pad2(d.getUTCMonth() + 1)}-${pad2(d.getUTCDate())}`;
    };
    const formatMonth01 = jd => {
      const d = Cesium.JulianDate.toDate(jd);
      return `${d.getUTCFullYear()}-${pad2(d.getUTCMonth() + 1)}-01`;
    };
    function snapTo16DayISO(jd) {
      const d = Cesium.JulianDate.toDate(jd);
      const day = Math.floor((Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()) - Date.UTC(d.getUTCFullYear(), 0, 1)) / 86400000) + 1;
      const snapped = day - ((day - 1) % 16);
      const snapDate = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      snapDate.setUTCDate(snapped);
      return `${snapDate.getUTCFullYear()}-${pad2(snapDate.getUTCMonth() + 1)}-${pad2(snapDate.getUTCDate())}`;
    }

    // --- Imagery loading helpers -------------------------------------------
    let tileProgress = 0;
    viewer.scene.globe.tileLoadProgressEvent.addEventListener(n => { tileProgress = n; });

    function waitUntilTilesSettled(baseline, timeoutMs = 9000) {
      return new Promise(resolve => {
        let stable = 0;
        const started = performance.now();
        function step() {
          stable = tileProgress <= baseline ? stable + 1 : 0;
          if (stable >= 2 || (performance.now() - started) > timeoutMs) {
            resolve();
          } else {
            requestAnimationFrame(step);
          }
        }
        requestAnimationFrame(step);
      });
    }

    function silence404(provider) {
      if (!provider) return;
      provider.errorEvent.addEventListener(evt => {
        const message = (evt && (evt.message || evt.error)) || "";
        if (/404|Not\sFound|NoSuchKey/i.test(String(message))) evt.retry = false;
      });
    }

    function safeAddProvider(provider) {
      try {
        return layers.addImageryProvider(provider);
      } catch (error) {
        console.warn("Layer skipped:", error?.message || error);
        return null;
      }
    }

    async function preloadAndCrossfade(oldLayer, buildLayer, targetAlpha = 1, fadeMs = 350) {
      const baseline = tileProgress;
      const layer = buildLayer();
      if (!layer) return oldLayer;
      layer.alpha = 0.0001;
      layer.show = true;
      await waitUntilTilesSettled(baseline);
      return new Promise(resolve => {
        const started = performance.now();
        function fade(now) {
          const t = Math.min((now - started) / fadeMs, 1);
          layer.alpha = targetAlpha * t;
          if (oldLayer) oldLayer.alpha = (1 - t) * (oldLayer.alpha ?? 1);
          viewer.scene.requestRender();
          if (t < 1) requestAnimationFrame(fade); else {
            if (oldLayer) layers.remove(oldLayer, true);
            resolve(layer);
          }
        }
        requestAnimationFrame(fade);
      });
    }

    // --- Imagery providers --------------------------------------------------
    function addAsterHillshade() {
      const provider = new Cesium.UrlTemplateImageryProvider({
        url: "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/ASTER_GDEM_Color_Shaded_Relief/default/2000-01-01/GoogleMapsCompatible_Level8/{z}/{y}/{x}.jpg",
        tilingScheme: new Cesium.WebMercatorTilingScheme(),
        maximumLevel: 8,
        credit: "NASA EOSDIS GIBS"
      });
      silence404(provider);
      const layer = safeAddProvider(provider);
      if (layer) {
        layer.rectangle = CA_RECT;
        layer.brightness = 0.9;
        layer.contrast = 1.05;
      }
      return layer;
    }

    function addViirsTrueColor(dayStr) {
      const provider = new Cesium.UrlTemplateImageryProvider({
        url: "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/VIIRS_SNPP_CorrectedReflectance_TrueColor/default/{Time}/GoogleMapsCompatible_Level9/{z}/{y}/{x}.jpg",
        tilingScheme: new Cesium.WebMercatorTilingScheme(),
        maximumLevel: 8,
        credit: "NASA EOSDIS GIBS",
        customTags: { Time: () => dayStr }
      });
      silence404(provider);
      const layer = safeAddProvider(provider);
      if (layer) layer.rectangle = CA_RECT;
      return layer;
    }

    function addNdvi16Day(dayStr16) {
      const provider = new Cesium.UrlTemplateImageryProvider({
        url: "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Terra_L3_NDVI_16Day/default/{Time}/GoogleMapsCompatible_Level9/{z}/{y}/{x}.png",
        tilingScheme: new Cesium.WebMercatorTilingScheme(),
        maximumLevel: 7,
        credit: "NASA EOSDIS GIBS",
        customTags: { Time: () => dayStr16 }
      });
      silence404(provider);
      const layer = safeAddProvider(provider);
      if (layer) layer.rectangle = CA_RECT;
      return layer;
    }

    function addLSTDay(dayStr) {
      const provider = new Cesium.UrlTemplateImageryProvider({
        url: "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Terra_Land_Surface_Temp_Day/default/{Time}/GoogleMapsCompatible_Level7/{z}/{y}/{x}.png",
        tilingScheme: new Cesium.WebMercatorTilingScheme(),
        maximumLevel: 7,
        credit: "NASA EOSDIS GIBS",
        customTags: { Time: () => dayStr }
      });
      silence404(provider);
      const layer = safeAddProvider(provider);
      if (layer) layer.rectangle = CA_RECT;
      return layer;
    }

    function addSnowCover(dayStr) {
      const provider = new Cesium.UrlTemplateImageryProvider({
        url: "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Terra_NDSI_Snow_Cover/default/{Time}/GoogleMapsCompatible_Level8/{z}/{y}/{x}.png",
        tilingScheme: new Cesium.WebMercatorTilingScheme(),
        maximumLevel: 8,
        credit: "NASA EOSDIS GIBS",
        customTags: { Time: () => dayStr }
      });
      silence404(provider);
      const layer = safeAddProvider(provider);
      if (layer) layer.rectangle = CA_RECT;
      return layer;
    }

    function addBurnedMonthly(monthStr) {
      const candidates = [
        "MODIS_Terra_Aqua_Burned_Area",
        "MODIS_Terra_Burned_Area_Monthly",
        "MCD64A1_Burned_Area"
      ];
      for (const id of candidates) {
        try {
          const provider = new Cesium.UrlTemplateImageryProvider({
            url: `https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/${id}/default/{Time}/GoogleMapsCompatible_Level6/{z}/{y}/{x}.png`,
            tilingScheme: new Cesium.WebMercatorTilingScheme(),
            maximumLevel: 6,
            credit: "NASA EOSDIS GIBS",
            customTags: { Time: () => monthStr }
          });
          silence404(provider);
          const layer = safeAddProvider(provider);
          if (layer) {
            layer.rectangle = CA_RECT;
            layer.__burnId = id;
            return layer;
          }
        } catch (error) {
          /* try next candidate */
        }
      }
      console.warn("Burned Area WMTS layer not available for", monthStr);
      return null;
    }

    function addAerosolDaily(dayStr) {
      const provider = new Cesium.UrlTemplateImageryProvider({
        url: "https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Terra_Aerosol/default/{Time}/GoogleMapsCompatible_Level9/{z}/{y}/{x}.png",
        tilingScheme: new Cesium.WebMercatorTilingScheme(),
        maximumLevel: 7,
        credit: "NASA EOSDIS GIBS",
        customTags: { Time: () => dayStr }
      });
      silence404(provider);
      const layer = safeAddProvider(provider);
      if (layer) layer.rectangle = CA_RECT;
      return layer;
    }

    // --- FIRMS detections ---------------------------------------------------
    let fireIconsEnabled = true;
    let firmsDataSource = null;
    let firmsAbort = null;
    const FIRMS_MAX_ENTITIES = 250;
    const FIRMS_MAX_MONTHS_CACHED = 6;
    const FIRMS_MIN_ENABLE_HEIGHT_KM = 7000;
    const ICON_SIZE = 48;

    const firmsLRU = new Map();

    function monthKeyFromDay(dayStr) {
      return dayStr.slice(0, 7);
    }

    function localMonthUrl(monthKey) {
      return `./data/firms/CA-${monthKey}.geojson`;
    }

    function lruGet(key) {
      if (!firmsLRU.has(key)) return null;
      const value = firmsLRU.get(key);
      firmsLRU.delete(key);
      firmsLRU.set(key, value);
      return value;
    }

    function lruSet(key, value) {
      if (firmsLRU.has(key)) firmsLRU.delete(key);
      firmsLRU.set(key, value);
      if (firmsLRU.size > FIRMS_MAX_MONTHS_CACHED) {
        const oldest = firmsLRU.keys().next().value;
        firmsLRU.delete(oldest);
      }
    }

    let fireIconCanvas = null;

    function makeEmojiCanvas(emoji = "üî•", size = ICON_SIZE) {
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext("2d");
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `${Math.floor(size * .9)}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
      ctx.fillText(emoji, size / 2, Math.ceil(size * .57));
      const glow = ctx.createRadialGradient(size / 2, size / 2, 4, size / 2, size / 2, size / 2);
      glow.addColorStop(0, "rgba(255,160,0,.15)");
      glow.addColorStop(1, "rgba(255,160,0,0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
      ctx.fill();
      return canvas;
    }

    function colorForConfidence(conf) {
      const value = String(conf).toLowerCase();
      if (value.startsWith("h") || +conf >= 80) return Cesium.Color.fromCssColorString("#ff3b30");
      if (value.startsWith("n") || (+conf >= 50 && +conf < 80)) return Cesium.Color.fromCssColorString("#ff9500");
      return Cesium.Color.fromCssColorString("#ffd60a");
    }

    function scaleForFrp(frp) {
      const value = Math.max(0, Math.min(1, (Number(frp) || 0) / 200));
      return 0.6 + value * 0.8;
    }

    const SAMPLE_FIRMS_GEOJSON = {
      type: "FeatureCollection",
      features: [
        { type: "Feature", properties: { acq_date: "2020-09-10", acq_time: "2015", confidence: "high", frp: 120, sat: "MODIS", id: "AUG1" }, geometry: { type: "Point", coordinates: [-123.3, 40.1] } },
        { type: "Feature", properties: { acq_date: "2020-09-10", acq_time: "2010", confidence: "high", frp: 95, sat: "MODIS", id: "AUG2" }, geometry: { type: "Point", coordinates: [-123.0, 40.4] } },
        { type: "Feature", properties: { acq_date: "2020-09-10", acq_time: "2005", confidence: "nominal", frp: 60, sat: "MODIS", id: "NORTH1" }, geometry: { type: "Point", coordinates: [-121.2, 39.8] } },
        { type: "Feature", properties: { acq_date: "2020-09-10", acq_time: "2012", confidence: "nominal", frp: 55, sat: "MODIS", id: "NORTH2" }, geometry: { type: "Point", coordinates: [-121.0, 40.0] } },
        { type: "Feature", properties: { acq_date: "2020-09-10", acq_time: "1959", confidence: "high", frp: 180, sat: "MODIS", id: "CREEK1" }, geometry: { type: "Point", coordinates: [-119.3, 37.2] } },
        { type: "Feature", properties: { acq_date: "2020-09-10", acq_time: "1952", confidence: "low", frp: 20, sat: "MODIS", id: "CREEK2" }, geometry: { type: "Point", coordinates: [-119.0, 37.0] } }
      ]
    };

    function cameraHeightKm() {
      return (viewer.camera.positionCartographic.height || 0) / 1000;
    }

    function getViewRectangle() {
      try {
        return viewer.camera.computeViewRectangle(viewer.scene.globe.ellipsoid) || CA_RECT;
      } catch (error) {
        return CA_RECT;
      }
    }

    function gridDegForHeight(km) {
      if (km > 5000) return 0.5;
      if (km > 2000) return 0.25;
      if (km > 800) return 0.1;
      if (km > 300) return 0.05;
      return 0.02;
    }

    function featureInRect(feature, rect) {
      const [lon, lat] = feature.geometry.coordinates;
      return (
        lon >= Cesium.Math.toDegrees(rect.west) &&
        lon <= Cesium.Math.toDegrees(rect.east) &&
        lat >= Cesium.Math.toDegrees(rect.south) &&
        lat <= Cesium.Math.toDegrees(rect.north)
      );
    }

    function decimateByGrid(features, rect, km) {
      const cell = gridDegForHeight(km);
      const cellMap = new Map();
      const toDeg = Cesium.Math.toDegrees;
      const west = toDeg(rect.west);
      const south = toDeg(rect.south);
      for (const feature of features) {
        if (!featureInRect(feature, rect)) continue;
        const [lon, lat] = feature.geometry.coordinates;
        const ix = Math.floor((lon - west) / cell);
        const iy = Math.floor((lat - south) / cell);
        const key = `${ix},${iy}`;
        const frp = Number((feature.properties && (feature.properties.frp ?? feature.properties.FRP)) || 0);
        const current = cellMap.get(key);
        if (!current || frp > (current._frp || 0)) {
          feature._frp = frp;
          cellMap.set(key, feature);
        }
      }
      const compact = Array.from(cellMap.values());
      if (compact.length > FIRMS_MAX_ENTITIES) {
        compact.sort((a, b) => (b._frp || 0) - (a._frp || 0));
        return compact.slice(0, FIRMS_MAX_ENTITIES);
      }
      return compact;
    }

    async function fetchLocalMonthGeoJSON(monthKey) {
      const cached = lruGet(monthKey);
      if (cached) return cached.geojson;
      if (firmsAbort) firmsAbort.abort();
      firmsAbort = new AbortController();
      const url = localMonthUrl(monthKey);
      try {
        const response = await fetch(url, { signal: firmsAbort.signal, cache: "force-cache" });
        if (!response.ok) throw new Error("missing month file");
        const geojson = await response.json();
        lruSet(monthKey, { geojson });
        return geojson;
      } catch (error) {
        return SAMPLE_FIRMS_GEOJSON;
      }
    }

    async function ensureFireIcons(dayStr) {
      if (!fireIconsEnabled) {
        if (firmsDataSource) {
          viewer.dataSources.remove(firmsDataSource, true);
          firmsDataSource = null;
        }
        document.getElementById("mIcons").textContent = "0";
        return;
      }

      const heightKm = cameraHeightKm();
      if (heightKm > FIRMS_MIN_ENABLE_HEIGHT_KM) {
        if (firmsDataSource) {
          viewer.dataSources.remove(firmsDataSource, true);
          firmsDataSource = null;
        }
        document.getElementById("mIcons").textContent = "0";
        return;
      }

      if (!fireIconCanvas) fireIconCanvas = makeEmojiCanvas("üî•", ICON_SIZE);
      const monthKey = monthKeyFromDay(dayStr);
      const monthGeo = await fetchLocalMonthGeoJSON(monthKey);
      const rect = getViewRectangle();
      const features = monthGeo?.features ? monthGeo.features : [];
      const decimated = decimateByGrid(features, rect, heightKm);
      const frameGeo = { type: "FeatureCollection", features: decimated };

      if (firmsDataSource) {
        viewer.dataSources.remove(firmsDataSource, true);
        firmsDataSource = null;
      }

      firmsDataSource = await Cesium.GeoJsonDataSource.load(frameGeo, { clampToGround: false });
      const entities = firmsDataSource.entities.values;
      for (const entity of entities) {
        const properties = entity.properties || {};
        const conf = properties.confidence && properties.confidence.getValue ? properties.confidence.getValue() : (properties.confidence || "nominal");
        const frp = properties.frp && properties.frp.getValue ? properties.frp.getValue() : (properties.frp || properties.FRP || 0);
        const date = properties.acq_date && properties.acq_date.getValue ? properties.acq_date.getValue() : (properties.acq_date || dayStr);
        const time = properties.acq_time && properties.acq_time.getValue ? properties.acq_time.getValue() : (properties.acq_time || "‚Äî");

        entity.point = undefined;
        entity.billboard = new Cesium.BillboardGraphics({
          image: fireIconCanvas,
          scale: scaleForFrp(frp),
          color: colorForConfidence(conf),
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          heightReference: Cesium.HeightReference.NONE,
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        });
        entity.label = new Cesium.LabelGraphics({
          text: `${conf} ‚Ä¢ FRP ${frp}`,
          font: "12px sans-serif",
          fillColor: Cesium.Color.WHITE,
          showBackground: true,
          backgroundColor: Cesium.Color.fromAlpha(Cesium.Color.BLACK, .6),
          pixelOffset: new Cesium.Cartesian2(0, -40)
        });
        entity.description = `
          <table class="meta-table">
            <tr><td><strong>Date</strong></td><td>${date} ${time}Z</td></tr>
            <tr><td><strong>Confidence</strong></td><td>${conf}</td></tr>
            <tr><td><strong>FRP</strong></td><td>${frp} MW</td></tr>
          </table>`;
      }

      firmsDataSource.clustering.enabled = true;
      firmsDataSource.clustering.pixelRange = 30;
      firmsDataSource.clustering.minimumClusterSize = 3;
      firmsDataSource.clustering.clusterEvent.addEventListener((clustered, cluster) => {
        cluster.label.show = true;
        cluster.label.font = "14px sans-serif";
        cluster.label.fillColor = Cesium.Color.WHITE;
        cluster.billboard.show = true;
        cluster.point.show = false;
        const size = 44;
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext("2d");
        const gradient = ctx.createLinearGradient(0, 0, size, size);
        gradient.addColorStop(0, "#ff6a00");
        gradient.addColorStop(1, "#ff2d55");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.9)";
        ctx.lineWidth = 3;
        ctx.stroke();
        cluster.billboard.image = canvas;
        cluster.billboard.width = size;
        cluster.billboard.height = size;
        cluster.label.pixelOffset = new Cesium.Cartesian2(0, 0);
      });

      viewer.dataSources.add(firmsDataSource);
      document.getElementById("mIcons").textContent = String(entities.length);
    }

    // --- Layer rebuild ------------------------------------------------------
    let lastDay = null;
    let lastDay16 = null;
    let lastMonth01 = null;

    let hillLayer = null;
    let viirsLayer = null;
    let ndviLayer = null;
    let lstLayer = null;
    let snowLayer = null;
    let burnLayer = null;
    let aodLayer = null;

    let showHill = true;
    let showNDVI = true;
    let showLST = false;
    let showSnow = false;
    let showBurn = false;
    let showAOD = false;

    let rebuildBusy = false;
    let lastSwitchAt = 0;
    const MIN_SWITCH_MS = 800;

    async function rebuildFor(currentJD) {
      if (rebuildBusy) return;
      rebuildBusy = true;

      const dayStr = formatDay(currentJD);
      const dayStr16 = snapTo16DayISO(currentJD);
      const month01 = formatMonth01(currentJD);

      if (showHill) {
        if (!hillLayer) {
          hillLayer = addAsterHillshade();
          if (hillLayer) hillLayer.alpha = .85;
        }
      } else if (hillLayer) {
        layers.remove(hillLayer, true);
        hillLayer = null;
      }

      if (!viirsLayer || lastDay !== dayStr) {
        viirsLayer = await preloadAndCrossfade(viirsLayer, () => {
          const layer = addViirsTrueColor(dayStr);
          if (layer) layer.alpha = 0;
          return layer;
        }, 1, 350);
      }

      if (showNDVI) {
        if (!ndviLayer || lastDay16 !== dayStr16) {
          ndviLayer = await preloadAndCrossfade(ndviLayer, () => {
            const layer = addNdvi16Day(dayStr16);
            if (layer) layer.alpha = 0;
            return layer;
          }, .6, 350);
        }
      } else if (ndviLayer) {
        layers.remove(ndviLayer, true);
        ndviLayer = null;
      }

      if (showLST) {
        if (!lstLayer || lastDay !== dayStr) {
          lstLayer = await preloadAndCrossfade(lstLayer, () => {
            const layer = addLSTDay(dayStr);
            if (layer) layer.alpha = 0;
            return layer;
          }, .55, 350);
        }
      } else if (lstLayer) {
        layers.remove(lstLayer, true);
        lstLayer = null;
      }

      if (showSnow) {
        if (!snowLayer || lastDay !== dayStr) {
          snowLayer = await preloadAndCrossfade(snowLayer, () => {
            const layer = addSnowCover(dayStr);
            if (layer) layer.alpha = 0;
            return layer;
          }, .85, 350);
        }
      } else if (snowLayer) {
        layers.remove(snowLayer, true);
        snowLayer = null;
      }

      if (showBurn) {
        if (!burnLayer || lastMonth01 !== month01) {
          burnLayer = await preloadAndCrossfade(burnLayer, () => {
            const layer = addBurnedMonthly(month01);
            if (layer) layer.alpha = 0;
            return layer;
          }, .85, 350);
        }
      } else if (burnLayer) {
        layers.remove(burnLayer, true);
        burnLayer = null;
      }

      await ensureFireIcons(dayStr);

      if (showAOD) {
        if (!aodLayer || lastDay !== dayStr) {
          aodLayer = await preloadAndCrossfade(aodLayer, () => {
            const layer = addAerosolDaily(dayStr);
            if (layer) layer.alpha = 0;
            return layer;
          }, .6, 350);
        }
      } else if (aodLayer) {
        layers.remove(aodLayer, true);
        aodLayer = null;
      }

      lastDay = dayStr;
      lastDay16 = dayStr16;
      lastMonth01 = month01;
      lastSwitchAt = performance.now();
      rebuildBusy = false;

      document.getElementById("mDate").textContent = dayStr;
    }

    rebuildFor(viewer.clock.currentTime);
    viewer.clock.onTick.addEventListener(() => {
      const currentDay = formatDay(viewer.clock.currentTime);
      const elapsed = performance.now() - lastSwitchAt;
      if (currentDay !== lastDay && elapsed >= MIN_SWITCH_MS && !rebuildBusy) {
        rebuildFor(viewer.clock.currentTime);
      }
    });

    let viewMoveTimer = null;
    viewer.camera.changed.addEventListener(() => {
      if (!fireIconsEnabled) return;
      if (viewMoveTimer) clearTimeout(viewMoveTimer);
      viewMoveTimer = setTimeout(() => {
        ensureFireIcons(lastDay || formatDay(viewer.clock.currentTime));
      }, 220);
    });

    // --- Chapters -----------------------------------------------------------
    const area = (west, south, east, north) => Cesium.Rectangle.fromDegrees(west, south, east, north);

    const chapters = [
      {
        id: "fuel-stress",
        title: "Fuel Stress (drought years)",
        rect: area(-124.7, 35.0, -118.0, 41.8),
        date: "2015-08-16",
        cadence: "16d",
        layers: { hill: true, ndvi: true, lst: true, snow: true, burn: false, aod: false, fireIcons: true },
        what: "NDVI & LST during multi-year drought ‚Äî browning rangelands & stressed Sierra forests; diminished spring snow.",
        why: "Stressed fuels + earlier, hotter summers prime larger fires and reduce water for cities & farms."
      },
      {
        id: "ignition-spread",
        title: "Ignition & Spread (Aug/North/Creek 2020)",
        rect: area(-125, 35, -116, 43),
        date: "2020-09-10",
        cadence: "day",
        layers: { hill: true, ndvi: false, lst: false, snow: false, burn: true, aod: false, fireIcons: true },
        what: "Monthly burn scar (MCD64A1) + MODIS hotspots. Terrain shows windward/leeward effects & slope-driven spread.",
        why: "Large burned area aligned with terrain funnels; repeated burns shape habitat and watershed risk."
      },
      {
        id: "smoke-week",
        title: "Smoke Week (Bay Area & Valley)",
        rect: area(-124.7, 36.9, -120.6, 39.1),
        date: "2020-09-10",
        cadence: "day",
        layers: { hill: false, ndvi: false, lst: false, snow: false, burn: false, aod: true, fireIcons: true },
        what: "Daily AOD plumes march across the Central Valley & Bay; hotspots show source fires.",
        why: "Degraded air quality ‚Üí school closures, respiratory risk, outdoor work curtailment, transit disruptions."
      },
      {
        id: "recovery",
        title: "Recovery (6‚Äì24 months)",
        rect: area(-121.2, 36.7, -118.6, 38.1),
        date: "2021-08-01",
        cadence: "16d",
        layers: { hill: true, ndvi: true, lst: false, snow: false, burn: true, aod: false, fireIcons: false },
        what: "NDVI rebounding over the burn scar vs. monthly burn perimeter; slower on south-facing slopes.",
        why: "Slow recovery ‚Üí erosion & debris-flow hazard persists into first winter storms."
      }
    ];

    let currentChapterIdx = 0;
    const chapterSelect = document.getElementById("chapterSel");
    chapters.forEach((chapter, index) => {
      const option = document.createElement("option");
      option.value = String(index);
      option.textContent = chapter.title;
      chapterSelect.appendChild(option);
    });

    function updateCaption(chapter) {
      const caption = document.getElementById("caption");
      document.getElementById("capTitle").textContent = chapter.what;
      document.getElementById("capWhy").textContent = chapter.why;
      document.getElementById("mChapter").textContent = chapter.title;
      caption.classList.remove("show");
      void caption.offsetWidth;
      caption.classList.add("show");
    }

    async function applyChapter(chapter) {
      await viewer.camera.flyTo({ destination: chapter.rect, duration: 1.1 });
      const targetJD = Cesium.JulianDate.fromDate(new Date(chapter.date));
      viewer.clock.currentTime = targetJD;
      const defaults = { hill: true, ndvi: true, lst: false, snow: false, burn: false, aod: false, fireIcons: true };
      const prefs = Object.assign(defaults, chapter.layers || {});
      showHill = prefs.hill;
      showNDVI = prefs.ndvi;
      showLST = prefs.lst;
      showSnow = prefs.snow;
      showBurn = prefs.burn;
      showAOD = prefs.aod;
      fireIconsEnabled = prefs.fireIcons;

      chkHill.checked = showHill;
      chkNDVI.checked = showNDVI;
      chkLST.checked = showLST;
      chkSnow.checked = showSnow;
      chkBurn.checked = showBurn;
      chkAOD.checked = showAOD;
      chkFiresIcons.checked = fireIconsEnabled;

      await rebuildFor(targetJD);
      updateCaption(chapter);
    }

    async function goChapter(index) {
      currentChapterIdx = (index + chapters.length) % chapters.length;
      chapterSelect.value = String(currentChapterIdx);
      await applyChapter(chapters[currentChapterIdx]);
    }

    // --- UI wiring ----------------------------------------------------------
    const chkHill = document.getElementById("chkHill");
    const chkNDVI = document.getElementById("chkNDVI");
    const chkLST = document.getElementById("chkLST");
    const chkSnow = document.getElementById("chkSnow");
    const chkBurn = document.getElementById("chkBurn");
    const chkAOD = document.getElementById("chkAOD");
    const chkFiresIcons = document.getElementById("chkFiresIcons");
    const speedSel = document.getElementById("speed");
    const btnPlay = document.getElementById("btnPlay");
    const loading = document.getElementById("loading");

    chkHill.onchange = () => { showHill = chkHill.checked; rebuildFor(viewer.clock.currentTime); };
    chkNDVI.onchange = () => { showNDVI = chkNDVI.checked; rebuildFor(viewer.clock.currentTime); };
    chkLST.onchange = () => { showLST = chkLST.checked; rebuildFor(viewer.clock.currentTime); };
    chkSnow.onchange = () => { showSnow = chkSnow.checked; rebuildFor(viewer.clock.currentTime); };
    chkBurn.onchange = () => { showBurn = chkBurn.checked; rebuildFor(viewer.clock.currentTime); };
    chkAOD.onchange = () => { showAOD = chkAOD.checked; rebuildFor(viewer.clock.currentTime); };
    chkFiresIcons.onchange = async () => {
      fireIconsEnabled = chkFiresIcons.checked;
      await ensureFireIcons(lastDay || formatDay(viewer.clock.currentTime));
    };

    document.getElementById("btnPrev").onclick = () => goChapter(currentChapterIdx - 1);
    document.getElementById("btnNext").onclick = () => goChapter(currentChapterIdx + 1);
    chapterSelect.onchange = event => goChapter(Number(event.target.value));

    function addPin(lon, lat, text) {
      viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(lon, lat),
        point: { pixelSize: 8, color: Cesium.Color.RED },
        label: { text, font: "13px sans-serif", pixelOffset: new Cesium.Cartesian2(0, -16) }
      });
    }

    document.getElementById("btnTestFires").onclick = async () => {
      const testJD = Cesium.JulianDate.fromDate(new Date(Date.UTC(2020, 8, 10)));
      viewer.clock.currentTime = testJD;
      viewer.clock.shouldAnimate = false;
      await viewer.camera.flyTo({ destination: Cesium.Rectangle.fromDegrees(-125, 35, -116, 43), duration: 1.2 });
      addPin(-123.3, 40.1, "August Complex");
      addPin(-121.2, 39.8, "North Complex");
      addPin(-119.3, 37.2, "Creek Fire");
      await rebuildFor(testJD);
    };

    btnPlay.onclick = () => {
      viewer.clock.shouldAnimate = !viewer.clock.shouldAnimate;
      btnPlay.textContent = viewer.clock.shouldAnimate ? "‚è∏Ô∏é" : "‚èØÔ∏é";
    };

    speedSel.onchange = () => {
      viewer.clock.multiplier = Number(speedSel.value);
    };

    viewer.scene.globe.tileLoadProgressEvent.addEventListener(num => {
      loading.textContent = num ? `loading tiles: ${num}` : "";
    });

    viewer.entities.add({
      position: Cesium.Cartesian3.fromDegrees(-124.2, 42.7),
      label: {
        text: "ASTER Hillshade + VIIRS True Color + MODIS: NDVI ‚Ä¢ LST ‚Ä¢ Snow ‚Ä¢ Burned Area ‚Ä¢ AOD + FIRMS fire detections",
        font: "14px sans-serif",
        fillColor: Cesium.Color.WHITE,
        showBackground: true
      }
    });

    viewer.clock.shouldAnimate = true;
    btnPlay.textContent = "‚è∏Ô∏é";
    document.getElementById("mNotes").textContent = "Fire detections use local monthly FIRMS GeoJSON ‚Ä¢ Other layers stream from NASA GIBS";

    goChapter(0);
  </script>
</body>
</html>
